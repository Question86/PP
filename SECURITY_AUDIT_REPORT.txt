================================================================================
SECURITY AUDIT REPORT - PromptPage V2
================================================================================

Date: 2026-01-03
Auditor: AI Security Review
Status: 3 HIGH, 2 MED, 1 LOW findings
Recommendation: DO NOT PUSH TO GITHUB UNTIL HIGH FINDINGS RESOLVED

================================================================================
EXECUTIVE SUMMARY
================================================================================

Found 2 BLOCKING issues that must be fixed before GitHub push:

1. SQL Injection in createCompositionItems() - String interpolation allows 
   injection via creator_payout_address

2. Missing Authorization in confirm endpoint - Any user can confirm any 
   composition with valid payment

Additional 4 findings rated MED/LOW require attention but not blocking.

================================================================================
FINDING 1: SQL INJECTION IN createCompositionItems() [HIGH]
================================================================================

File: src/lib/db-compositions.ts
Lines: 198-205
Severity: HIGH (Database compromise possible)

VULNERABLE CODE:
--------------------------------------------------------------------------------
const values = items
  .map(
    (item) =>
      `(${item.composition_id}, ${item.snippet_version_id}, '${item.creator_payout_address}', ${item.price_nanoerg}, ${item.position})`
  )
  .join(', ');

await pool.execute(
  `INSERT INTO composition_items (composition_id, snippet_version_id, creator_payout_address, price_nanoerg, position)
   VALUES ${values}`
);
--------------------------------------------------------------------------------

VULNERABILITY:
String interpolation of creator_payout_address without escaping. If a 
malicious address like '; DROP TABLE compositions; -- exists in DB, SQL 
injection occurs.

ATTACK VECTOR:
1. Attacker creates creator with malicious payout address
2. System selects attacker's snippet for composition
3. propose endpoint calls createCompositionItems()
4. SQL injection executes

CODE FIX:
--------------------------------------------------------------------------------
export async function createCompositionItems(
  items: Omit<CompositionItem, 'id'>[]
): Promise<void> {
  if (items.length === 0) return;

  // Use parameterized query with multiple value sets
  const placeholders = items.map(() => '(?, ?, ?, ?, ?)').join(', ');
  const flatValues: any[] = [];
  
  items.forEach(item => {
    flatValues.push(
      item.composition_id,
      item.snippet_version_id,
      item.creator_payout_address,
      item.price_nanoerg,
      item.position
    );
  });

  await pool.execute(
    `INSERT INTO composition_items (composition_id, snippet_version_id, creator_payout_address, price_nanoerg, position)
     VALUES ${placeholders}`,
    flatValues
  );
}
--------------------------------------------------------------------------------

EXACT REPLACEMENT:
Replace lines 198-207 in src/lib/db-compositions.ts:

OLD CODE:
--------------------------------------------------------------------------------
export async function createCompositionItems(
  items: Omit<CompositionItem, 'id'>[]
): Promise<void> {
  if (items.length === 0) return;

  const values = items
    .map(
      (item) =>
        `(${item.composition_id}, ${item.snippet_version_id}, '${item.creator_payout_address}', ${item.price_nanoerg}, ${item.position})`
    )
    .join(', ');

  await pool.execute(
    `INSERT INTO composition_items (composition_id, snippet_version_id, creator_payout_address, price_nanoerg, position)
     VALUES ${values}`
  );
}
--------------------------------------------------------------------------------

NEW CODE:
--------------------------------------------------------------------------------
export async function createCompositionItems(
  items: Omit<CompositionItem, 'id'>[]
): Promise<void> {
  if (items.length === 0) return;

  // Use parameterized query with multiple value sets
  const placeholders = items.map(() => '(?, ?, ?, ?, ?)').join(', ');
  const flatValues: any[] = [];
  
  items.forEach(item => {
    flatValues.push(
      item.composition_id,
      item.snippet_version_id,
      item.creator_payout_address,
      item.price_nanoerg,
      item.position
    );
  });

  await pool.execute(
    `INSERT INTO composition_items (composition_id, snippet_version_id, creator_payout_address, price_nanoerg, position)
     VALUES ${placeholders}`,
    flatValues
  );
}
--------------------------------------------------------------------------------

================================================================================
FINDING 2: SQL INJECTION RISK IN propose ROUTE [HIGH]
================================================================================

File: src/app/api/compositions/propose/route.ts
Lines: 66-73
Severity: HIGH (Pattern risk - currently safe but fragile)

CURRENT CODE:
--------------------------------------------------------------------------------
const snippetVersionIds = selection.candidates.map(c => c.snippet_version_id);
const placeholders = snippetVersionIds.map(() => '?').join(',');

const [rows] = await pool.execute<RowDataPacket[]>(
  `SELECT sv.id as snippet_version_id, c.payout_address
   FROM snippet_versions sv
   INNER JOIN snippets s ON s.id = sv.snippet_id
   INNER JOIN creators c ON c.id = s.creator_id
   WHERE sv.id IN (${placeholders})`,
  snippetVersionIds
);
--------------------------------------------------------------------------------

ISSUE:
While currently using parameterized queries correctly, the dynamic IN clause 
is easily broken during refactoring. IDs come from selection algorithm which 
could be manipulated.

CODE FIX:
--------------------------------------------------------------------------------
// Get creator payout addresses for ALL snippets in ONE query (no N+1)
const snippetVersionIds = selection.candidates.map(c => c.snippet_version_id);

// ADDED: Validate all IDs are positive integers
const validatedIds = snippetVersionIds.filter(id => Number.isInteger(id) && id > 0);
if (validatedIds.length !== snippetVersionIds.length) {
  return NextResponse.json(
    { error: 'Invalid snippet version IDs detected' },
    { status: 400 }
  );
}

const placeholders = validatedIds.map(() => '?').join(',');

const [rows] = await pool.execute<RowDataPacket[]>(
  `SELECT sv.id as snippet_version_id, c.payout_address
   FROM snippet_versions sv
   INNER JOIN snippets s ON s.id = sv.snippet_id
   INNER JOIN creators c ON c.id = s.creator_id
   WHERE sv.id IN (${placeholders})`,
  validatedIds
);
--------------------------------------------------------------------------------

EXACT REPLACEMENT:
Replace lines 64-73 in src/app/api/compositions/propose/route.ts:

OLD CODE:
--------------------------------------------------------------------------------
    // Get creator payout addresses for ALL snippets in ONE query (no N+1)
    const snippetVersionIds = selection.candidates.map(c => c.snippet_version_id);
    const placeholders = snippetVersionIds.map(() => '?').join(',');
    
    const [rows] = await pool.execute<RowDataPacket[]>(
      `SELECT sv.id as snippet_version_id, c.payout_address
       FROM snippet_versions sv
       INNER JOIN snippets s ON s.id = sv.snippet_id
       INNER JOIN creators c ON c.id = s.creator_id
       WHERE sv.id IN (${placeholders})`,
      snippetVersionIds
    );
--------------------------------------------------------------------------------

NEW CODE:
--------------------------------------------------------------------------------
    // Get creator payout addresses for ALL snippets in ONE query (no N+1)
    const snippetVersionIds = selection.candidates.map(c => c.snippet_version_id);
    
    // Validate all IDs are positive integers
    const validatedIds = snippetVersionIds.filter(id => Number.isInteger(id) && id > 0);
    if (validatedIds.length !== snippetVersionIds.length) {
      return NextResponse.json(
        { error: 'Invalid snippet version IDs detected' },
        { status: 400 }
      );
    }
    
    const placeholders = validatedIds.map(() => '?').join(',');
    
    const [rows] = await pool.execute<RowDataPacket[]>(
      `SELECT sv.id as snippet_version_id, c.payout_address
       FROM snippet_versions sv
       INNER JOIN snippets s ON s.id = sv.snippet_id
       INNER JOIN creators c ON c.id = s.creator_id
       WHERE sv.id IN (${placeholders})`,
      validatedIds
    );
--------------------------------------------------------------------------------

================================================================================
FINDING 3: MISSING OWNERSHIP CHECK IN confirm ENDPOINT [HIGH]
================================================================================

File: src/app/api/compositions/[id]/confirm/route.ts
Lines: 14-56
Severity: HIGH (Payment hijacking possible)

VULNERABILITY:
Endpoint verifies transaction amounts but NOT that the caller owns the 
composition.

ATTACK SCENARIO:
1. Alice creates composition #5, locks it (status: awaiting_payment)
2. Bob discovers composition #5 exists
3. Bob creates transaction paying correct amounts to platform + creators
4. Bob calls /api/compositions/5/confirm with his txId
5. System verifies amounts match, marks composition as paid
6. Alice loses access to composition despite being owner

CODE FIX STEP 1: Update Type Definition
--------------------------------------------------------------------------------
File: src/types/v2.ts

Find the ConfirmPaymentRequest interface and change from:

export interface ConfirmPaymentRequest {
  txId: string;
}

To:

export interface ConfirmPaymentRequest {
  txId: string;
  userAddress: string;
}
--------------------------------------------------------------------------------

CODE FIX STEP 2: Update confirm Route
--------------------------------------------------------------------------------
File: src/app/api/compositions/[id]/confirm/route.ts

Replace lines 14-56 with:

OLD CODE:
--------------------------------------------------------------------------------
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const compositionId = parseInt(params.id);
    if (isNaN(compositionId)) {
      return NextResponse.json(
        { error: 'Invalid composition ID' },
        { status: 400 }
      );
    }

    const body: ConfirmPaymentRequest = await request.json();

    // Validate txId
    if (!body.txId || body.txId.trim().length < 32) {
      return NextResponse.json(
        { error: 'Valid transaction ID is required' },
        { status: 400 }
      );
    }

    const txId = body.txId.trim();

    // Get composition
    const composition = await getCompositionById(compositionId);
    if (!composition) {
      return NextResponse.json(
        { error: 'Composition not found' },
        { status: 404 }
      );
    }

    // Check status
    if (composition.status !== 'awaiting_payment') {
      return NextResponse.json(
        {
          error: `Composition is in ${composition.status} status`,
          currentStatus: composition.status,
        },
        { status: 400 }
      );
    }
--------------------------------------------------------------------------------

NEW CODE:
--------------------------------------------------------------------------------
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const compositionId = parseInt(params.id);
    if (isNaN(compositionId)) {
      return NextResponse.json(
        { error: 'Invalid composition ID' },
        { status: 400 }
      );
    }

    const body: ConfirmPaymentRequest = await request.json();

    // Validate txId
    if (!body.txId || body.txId.trim().length < 32) {
      return NextResponse.json(
        { error: 'Valid transaction ID is required' },
        { status: 400 }
      );
    }

    // Validate user address
    if (!body.userAddress || body.userAddress.trim().length < 10) {
      return NextResponse.json(
        { error: 'Valid user address is required' },
        { status: 400 }
      );
    }

    const txId = body.txId.trim();

    // Get composition
    const composition = await getCompositionById(compositionId);
    if (!composition) {
      return NextResponse.json(
        { error: 'Composition not found' },
        { status: 404 }
      );
    }

    // Verify ownership
    if (composition.user_address.toLowerCase() !== body.userAddress.toLowerCase()) {
      return NextResponse.json(
        { error: 'Forbidden: Not your composition' },
        { status: 403 }
      );
    }

    // Check status
    if (composition.status !== 'awaiting_payment') {
      return NextResponse.json(
        {
          error: `Composition is in ${composition.status} status`,
          currentStatus: composition.status,
        },
        { status: 400 }
      );
    }
--------------------------------------------------------------------------------

CODE FIX STEP 3: Update Frontend Call
--------------------------------------------------------------------------------
File: src/app/pay/[id]/page.tsx

Find the confirm API call (around line 180-190) and change from:

const confirmResponse = await fetch(`/api/compositions/${compositionId}/confirm`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ txId: txId }),
});

To:

const confirmResponse = await fetch(`/api/compositions/${compositionId}/confirm`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ 
    txId: txId,
    userAddress: wallet.address
  }),
});
--------------------------------------------------------------------------------

================================================================================
FINDING 4: NO RATE LIMITING ON lock ENDPOINT [MEDIUM]
================================================================================

File: src/app/api/compositions/[id]/lock/route.ts
Severity: MEDIUM (DoS risk)

ISSUE:
Endpoint can be spammed by composition owner to trigger:
- Repeated DB writes (status updates)
- Repeated aggregation queries
- Repeated R4 commitment computations

CURRENT BEHAVIOR:
- User can call lock on already-locked composition
- Status updates from 'awaiting_payment' back to 'awaiting_payment'
- No limit on frequency

MINIMAL FIX (Add Idempotency Check):
--------------------------------------------------------------------------------
File: src/app/api/compositions/[id]/lock/route.ts

Replace lines 60-68 with:

OLD CODE:
--------------------------------------------------------------------------------
    // Check status
    if (composition.status !== 'proposed') {
      return NextResponse.json(
        {
          error: `Cannot lock composition in ${composition.status} status`,
          currentStatus: composition.status,
        },
        { status: 400 }
      );
    }
--------------------------------------------------------------------------------

NEW CODE:
--------------------------------------------------------------------------------
    // Check status
    if (composition.status !== 'proposed') {
      // If already locked, return existing payment intent (idempotent)
      if (composition.status === 'awaiting_payment') {
        const creatorPayouts = await getAggregatedCreatorPayouts(compositionId);
        
        const paymentIntent: PaymentIntent = {
          compositionId,
          platformOutput: {
            address: PLATFORM_ERGO_ADDRESS,
            amount: PLATFORM_FEE_NANOERG.toString(),
          },
          creatorOutputs: creatorPayouts.map((payout) => ({
            address: payout.creator_address,
            amount: payout.total_amount,
            snippetCount: payout.snippet_count,
            snippetVersionIds: payout.snippet_version_ids,
          })),
          memo: compositionId.toString(),
          totalRequired: composition.total_price_nanoerg,
          estimatedFee: '1000000',
          protocolVersion: 1,
        };
        
        const commitmentHex = computeCommitment(paymentIntent);
        paymentIntent.commitmentHex = commitmentHex;
        
        return NextResponse.json({ paymentIntent });
      }
      
      return NextResponse.json(
        {
          error: `Cannot lock composition in ${composition.status} status`,
          currentStatus: composition.status,
        },
        { status: 400 }
      );
    }
--------------------------------------------------------------------------------

================================================================================
FINDING 5: EXPLORER API HAMMERING ON confirm [LOW]
================================================================================

File: src/app/api/compositions/[id]/confirm/route.ts
Severity: LOW (Minor abuse vector)

ISSUE:
Attacker can submit random txIds causing Explorer API calls.

MITIGATION ALREADY PRESENT:
- Duplicate txIds rejected by DB UNIQUE constraint (line 65-68)
- Invalid txIds return 404 from Explorer (no retry spam)

OPTIONAL HARDENING (Add Format Validation):
--------------------------------------------------------------------------------
File: src/app/api/compositions/[id]/confirm/route.ts

Add after line 41 (after txId trim):

const txId = body.txId.trim();

// Validate txId format (64 hex characters)
if (!/^[a-f0-9]{64}$/i.test(txId)) {
  return NextResponse.json(
    { error: 'Invalid transaction ID format' },
    { status: 400 }
  );
}
--------------------------------------------------------------------------------

================================================================================
FINDING 6: NO ERGO ADDRESS FORMAT VALIDATION [LOW]
================================================================================

Files: Multiple API routes
Severity: LOW (Input validation improvement)

CURRENT:
Only checks length (>10 characters)

RECOMMENDATION:
Create helper function and use across all routes.

CODE FIX STEP 1: Create Validation Helper
--------------------------------------------------------------------------------
Create new file: src/lib/validation.ts

export function isValidErgoAddress(address: string): boolean {
  if (!address || typeof address !== 'string') return false;
  
  const trimmed = address.trim();
  
  // P2PK addresses start with '9', P2S with '3'
  if (!trimmed.startsWith('3') && !trimmed.startsWith('9')) return false;
  
  // Standard address length
  if (trimmed.length < 51 || trimmed.length > 52) return false;
  
  // Base58 character set
  if (!/^[1-9A-HJ-NP-Za-km-z]+$/.test(trimmed)) return false;
  
  return true;
}
--------------------------------------------------------------------------------

CODE FIX STEP 2: Use in API Routes
--------------------------------------------------------------------------------
In files:
- src/app/api/compositions/[id]/lock/route.ts
- src/app/api/compositions/[id]/confirm/route.ts
- src/app/api/requests/route.ts

Add import:
import { isValidErgoAddress } from '@/lib/validation';

Replace address validation from:

if (!body.userAddress || body.userAddress.trim().length < 10) {
  return NextResponse.json(
    { error: 'Valid user address is required' },
    { status: 400 }
  );
}

To:

if (!body.userAddress || !isValidErgoAddress(body.userAddress)) {
  return NextResponse.json(
    { error: 'Invalid Ergo address format' },
    { status: 400 }
  );
}
--------------------------------------------------------------------------------

================================================================================
SECRETS & LOGGING CHECK: PASS
================================================================================

VERIFIED:
- .env and .env*.local properly gitignored
- No real credentials in .env.example
- setup-test-data.js masks passwords in logs
- No console.log(DATABASE_URL) or console.log(process.env) found
- No wallet mnemonics or private keys in codebase
- Documentation uses only placeholder credentials

================================================================================
PAYMENT VERIFICATION INTEGRITY: PASS
================================================================================

VERIFIED:
- UTXO-safe verification (sums all outputs per address)
- Case-insensitive address comparison
- Uses >= not == for amount checks
- Strict R4 commitment mode enforced
- Requires 1+ confirmations (prevents 0-conf attacks)
- MIN_BOX_VALUE validation before tx building

================================================================================
PRIORITY MATRIX
================================================================================

Priority | Finding                                | Action Required
---------|----------------------------------------|------------------
P0       | SQL injection in createCompositionItems | FIX CODE NOW
P0       | Missing ownership check in confirm      | FIX CODE NOW
P1       | SQL injection risk in propose route     | ADD VALIDATION
P2       | No rate limiting on lock                | ADD IDEMPOTENCY
P3       | Explorer hammering on confirm           | OPTIONAL
P3       | No Ergo address validation              | OPTIONAL

================================================================================
RECOMMENDED COMMIT SEQUENCE
================================================================================

Commit 1: Fix SQL Injection (BLOCKING)
---------------------------------------
git commit -m "security: fix SQL injection in createCompositionItems"

Files changed:
- src/lib/db-compositions.ts (lines 198-218)

Commit 2: Add Ownership Check (BLOCKING)
-----------------------------------------
git commit -m "security: add ownership verification to confirm endpoint"

Files changed:
- src/types/v2.ts (ConfirmPaymentRequest interface)
- src/app/api/compositions/[id]/confirm/route.ts (lines 35-45)
- src/app/pay/[id]/page.tsx (confirm API call)

Commit 3: Harden Input Validation (HIGH)
-----------------------------------------
git commit -m "security: add input validation to propose route"

Files changed:
- src/app/api/compositions/propose/route.ts (lines 66-76)

Commit 4: Add Lock Idempotency (MEDIUM)
----------------------------------------
git commit -m "perf: add idempotency to lock endpoint"

Files changed:
- src/app/api/compositions/[id]/lock/route.ts (lines 60-98)

================================================================================
FINAL VERDICT
================================================================================

STATUS: DO NOT PUSH TO GITHUB

BLOCKING ISSUES: 2 HIGH severity findings must be resolved

AFTER FIXES: Application will have acceptable security posture for:
- Public GitHub repository
- Testnet deployment
- MVP user testing

NOT READY FOR:
- Mainnet deployment (requires rate limiting, enhanced AuthZ)
- Production use (requires comprehensive audit)

================================================================================
NEXT STEPS
================================================================================

1. Apply P0 fixes (commits 1-2)
2. Run test suite to verify no breakage
3. Test E2E flow with ownership checks
4. Re-run this audit
5. Push to GitHub when clear

================================================================================
END OF REPORT
================================================================================
